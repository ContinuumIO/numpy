=========================
NumPy 1.8.0 Release Notes
=========================

This release supports  Python 2.6 -2.7 and 3.1 - 3.3. Support for  Python
2.4 and 2.5 has been dropped.



Highlights
==========


Compatibility notes
===================

numpy.diag, np.diagonal, and the diagonal method of ndarrays return a view
onto the original array, instead of producing a copy.

selecting multiple fields out of an array also produces a view.

The hash function of numpy.void scalars has been changed.  Previously the
pointer to the data was hashed as an integer.  Now, the hash function uses
the tuple-hash algorithm to combine the hash functions of the elements of
the scalar, but only if the scalar is read-only.

New features
============

In place fancy indexing for ufuncs
----------------------------------
The function ``at`` has been added to ufunc objects to allow in place
ufuncs using fancy indexing with no buffering. For example, the following
will increment the first and second items in the array, and will increment
the third item twice:
numpy.add.at(array, [0, 1, 2, 2], 1)

This is similar to doing array[[0, 1, 2, 2]] += 1

umath_linalg module
-------------------
This module provides gufuncs for several functions that were already present
in numpy.linalg. Thre are some extra functions thrown in.

Having them as gufuncs allows broadcasting of calls, which can be useful when
there are various problems to solve.

The functions are members of a module currently at numpy.core.umath_linalg

Masked-arrays
----------------------------

Preliminary support for NA missing values similar to those in R has
been implemented.  This was done by adding an NA mask to an array sub-type

.. note:: The NA API is *experimental*, and may undergo changes in future
   versions of NumPy.  The current implementation based on masks will 
   likely be supplemented by a second one based on bit-patterns, and it 
   is possible that a difference will be made between missing and 
   ignored data.

While a significant amount of the NumPy functionality has been extended to
support NA masks, not everything is yet supported. Here is an (incomplete)
list of things that do and do not work with NA values:

What works with NA:
    * Basic indexing and slicing, as well as full boolean mask indexing.
    * All element-wise ufuncs.
    * All UFunc.reduce methods, with a new skipna parameter.
    * np.all and np.any satisfy the rules NA | True == True and
      NA & False == False
    * The nditer object.
    * Array methods:
       + ndarray.clip, ndarray.min, ndarray.max, ndarray.sum, ndarray.prod,
         ndarray.conjugate, ndarray.diagonal, ndarray.flatten
       + numpy.concatenate, numpy.column_stack, numpy.hstack,
         numpy.vstack, numpy.dstack, numpy.squeeze, numpy.mean, numpy.std,
         numpy.var

What doesn't work with NA:
    * Fancy indexing, such as with lists and partial boolean masks.
    * ndarray.flat and any other methods that use the old iterator
      mechanism instead of the newer nditer.
    * Struct dtypes, which will have corresponding struct masks with
      one mask value per primitive field of the struct dtype.
    * UFunc.accumulate, UFunc.reduceat.
    * Ufunc calls with both NA masks and a where= mask at the same time.
    * File I/O has not been extended to support NA-masks.
    * np.logical_and and np.logical_or don't satisfy the
      rules NA | True == True and NA & False == False yet.
    * Array methods:
       + ndarray.argmax, ndarray.argmin,
       + numpy.repeat, numpy.delete (relies on fancy indexing),
         numpy.append, numpy.insert (relies on fancy indexing),
         numpy.where,

Differences with R:
    * R's parameter rm.na=T is spelled skipna=True in NumPy.
    * np.isna(nan) is False, but R's is.na(nan) is TRUE. This is because
      NumPy's NA is treated independently of the underlying data type.
    * Boolean indexing, where the result is compressed to just
      the elements with true in the mask, raises if the boolean mask
      has an NA value in it. This is because that value could be either
      True or False, meaning the count of the output array is actually
      NA. R treats this case in a manner inconsistent with the NA model,
      returning NA values in the spots where the boolean index has NA.
      This may have a practical advantage in spite of violating the
      NA theoretical model, so NumPy could adopt the behavior if necessary


New argument to searchsorted
----------------------------

The function searchsorted now accepts a 'sorter' argument that is a
permuation array that sorts the array to search.

C API
-----


New function ``PyUFunc_RegisterLoopForStructType`` provides a way to
register a ufunc for a structured array. For example, a ufunc could be
registered for an array with dtype 'u8,u8,u8'.

The op_flags and iter_flags fields for PyUFuncObject type are now exposed
and can be set at the C level. This is the same functionality that is
already available with nditer objects in the Python API. For example, the
first ufunc operand can be modified in place by writing the appropriate
ufunc loop and setting ufunc->op_flags[0] = NPY_ITER_READWRITE before
calling PyUFunc_RegisterLoopForType.

Changes
=======

General
-------


Deprecations
============

General
-------

Use of non-integer indices has been deprecated. Previously float indices
were truncated to integers without warning.

C-API
-----

